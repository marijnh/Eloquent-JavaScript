:chap_num: 2
:prev_link: 01_values
:next_link: 03_functions

= Program Structure =

In this chapter, we will start to do
things that can actually be called _programming_. We will expand our
command of the JavaScript language beyond the nouns and sentence
fragments we've seen so far, to the point where we can
express some meaningful prose.

== Expressions and statements ==

(((grammar)))(((syntax)))(((code,structure
of)))(((grammar)))(((JavaScript,syntax)))In
link:01_values.html#values[Chapter 1], we made some values and then
applied operators to them to get new values. Creating values like this
is an essential part of every JavaScript program, but it is only
a part.

(((literal expression)))A fragment of code that produces a value is
called an _((expression))_. Every value that is written literally
(such as `22` or `"psychoanalysis"`) is an expression. An expression
between ((parentheses)) is also an expression, as is a ((binary
operator)) applied to two expressions or a unary operator applied to
one.

(((nesting,of expressions)))(((human language)))This shows part of the
beauty of a language-based interface. Expressions can nest in a way
very similar to the way subsentences in human languages are nested—a
subsentence can contain its own subsentences, and so on. This allows
us to combine expressions to express arbitrarily complex computations.

(((statement)))(((semicolon)))(((program)))If an expression
corresponds to a sentence fragment, a JavaScript _statement_
corresponds to a full sentence in a human language. A program is
simply a list of statements.

(((syntax)))The simplest kind of statement is an expression with a
semicolon after it. This is a program:

[source,javascript]
----
1;
!false;
----

It is a useless program, though. An ((expression)) can be content to
just produce a value, which can then be used by the enclosing
expression. A ((statement)) stands on its own and amounts to something
only if it affects the world. It could display something on the
screen—that counts as changing the world—or it could change the
internal state of the machine in a way that will affect the statements
that come after it. These changes are called _((side effect))s_. The
statements in the previous example just produce the values `1` and
`true` and then immediately throw them away. This leaves no impression
on the world at all. When executing the program, nothing observable
happens.

(((programming style)))(((automatic semicolon
insertion)))(((semicolon)))In some cases, JavaScript allows you to
omit the semicolon at the end of a statement. In other cases, it has
to be there, or the next ((line)) will be treated as part of the same
statement. The rules for when it can be safely omitted are somewhat
complex and error-prone. In this book, every statement that needs a
semicolon will always be terminated by one. I recommend you do the
same in your own programs, at least until you've learned more about
subtleties involved in leaving out semicolons.

== Variables ==

(((syntax)))(((variable,definition)))(((side effect)))(((memory)))How
does a program keep an internal ((state))? How does it remember
things? We have seen how to produce new values from old values, but
this does not change the old values, and the new value has to be
immediately used or it will dissipate again. To catch and hold values,
JavaScript provides a thing called a _variable_.

[source,javascript]
----
var caught = 5 * 5;
----

(((var keyword)))And that gives us our second kind of ((statement)).
The special word (_((keyword))_) `var` indicates that this sentence is
going to define a variable. It is followed by the name of the variable
and, if we want to immediately give it a value, by an `=` operator and
an expression.

The previous statement creates a variable called `caught` and uses it
to grab hold of the number that is produced by multiplying 5 by 5.

After a variable has been defined, its name can be used as an
((expression)). The value of such an expression is the value the
variable currently holds. Here's an example:

[source,javascript]
----
var ten = 10;
console.log(ten * ten);
// → 100
----

(((underscore character)))(((dollar
sign)))(((variable,naming)))Variable names can be any word that isn't
a reserved word (such as `var`). They may not include spaces.
Digits can also be part of variable names—`catch22` is a valid name,
for example—but the name must not start with a digit. A variable name
cannot include punctuation, except for the characters `$` and `_`.

(((var keyword)))A single `var` statement may define multiple
variables. The definitions must be separated by commas.

[source,javascript]
----
var one = 1, two = 2;
console.log(one + two);
// → 3
----

== Keywords and reserved words ==

(((syntax)))(((implements (reserved word))))(((interface (reserved
word))))(((let keyword)))(((package (reserved word))))(((private
(reserved word))))(((protected (reserved word))))(((public (reserved
word))))(((static (reserved word))))(((void operator)))(((yield
(reserved word))))(((reserved word)))(((variable,naming)))Words with
a special meaning, such as `var`, are _((keyword))s_, and they may not
be used as variable names. There are also a number of words that are
“reserved for use” in ((future)) versions of JavaScript. These are also
officially not allowed to be used as variable names, though some
JavaScript environments do allow them. The full list of keywords and
reserved words is rather long.

[source,text/plain]
----
break case catch class const continue debugger
default delete do else enum export extends false
finally for function if implements import in
instanceof interface let new null package private
protected public return static super switch this
throw true try typeof var void while with yield
----

Don't worry about memorizing these, but remember that this might be
the problem when a variable definition does not work as expected.

== The environment ==

(((standard environment)))The collection of variables and their values
that exist at a given time is called the _((environment))_. When a
program starts up, this environment is not empty. It always contains
variables that are part of the language ((standard)), and most of the
time, it has variables that provide ways to interact with the
surrounding system. For example, in a ((browser)), there are variables
and functions to inspect and influence the currently loaded website
and to read ((mouse)) and ((keyboard)) input.

== Functions ==

indexsee:[application (of functions),function application]
indexsee:[invoking (of functions),function application]
indexsee:[calling (of functions),function application]
(((output)))(((function)))(((function,application)))(((alert
function)))(((message box)))A lot of the values provided in the
default environment have the type _((function))_. A function is a
piece of program wrapped in a value. Such values can be _applied_ in
order to run the wrapped program. For example, in a ((browser))
environment, the variable `alert` holds a function that shows a little
((dialog box)) with a message. It is used like this:

[source,javascript]
----
alert("Good morning!");
----

image::img/alert.png[alt="An alert dialog",width="8cm"]

(((parameter)))(((function,application)))Executing a function is
called _invoking_, _calling_, or _applying_ it. You can call a
function by putting ((parentheses)) after an expression that produces a
function value. Usually you'll directly use the name of the variable
that holds the function. The values between the parentheses are given to
the program inside the function. In the example, the `alert` function
uses the string that we give it as the text to show in the dialog box.
Values given to functions are called _((argument))s_. The `alert`
function needs only one of them, but other functions might need a
different number or different types of arguments.

== The console.log function ==

(((JavaScript console)))(((developer
tools)))(((Node.js)))(((console.log)))(((output)))The `alert` function
can be useful as an output device when experimenting, but clicking
away all those little windows will get on your nerves. In past
examples, we've used `console.log` to output values. Most JavaScript
systems (including all modern web ((browser))s and Node.js) provide a
`console.log` function that writes out its arguments to _some_ text
output device. In browsers, the output lands in the ((JavaScript
console)). This part of the browser interface is hidden by default,
but most browsers open it when you press F12 or, on Mac, when you
press Command-Option-I. If that does not work, search through the
menus for an item named “web console” or “developer tools”.

ifdef::interactive_target[]

When running the examples, or your own code, on the pages of this
book, `console.log` output will be shown after the example, instead of
in the browser's JavaScript console.

endif::interactive_target[]

[source,javascript]
----
var x = 30;
console.log("the value of x is", x);
// → the value of x is 30
----

(((object)))Though ((variable)) names cannot contain ((period
character))s, `console.log` clearly has one. This is because
`console.log` isn't a simple variable. It is actually an expression
that retrieves the `log` ((property)) from the value held by the
`console` variable. We will find out exactly what this means in
link:04_data.html#properties[Chapter 4].

[[return_values]]
== Return values ==

(((comparison,of numbers)))(((return value)))(((Math.max
function)))(((maximum)))Showing a dialog box or writing text to
the screen is a _((side effect))_. A lot of functions are useful
because of the side effects they produce. Functions may also produce
values, and in that case, they don't need to have a side effect to be
useful. For example, the function `Math.max` takes any number of
number values and gives back the greatest.

[source,javascript]
----
console.log(Math.max(2, 4));
// → 4
----

(((function,application)))(((minimum)))(((Math.min
function)))When a function produces a value, it is said to _return_
that value. Anything that produces a value is an ((expression)) in
JavaScript, which means function calls can be used within larger
expressions. Here a call to `Math.min`, which is the opposite of
`Math.max`, is used as an input to the plus operator:

[source,javascript]
----
console.log(Math.min(2, 4) + 100);
// → 102
----

The link:03_functions.html#functions[next chapter] explains how to
write your own functions.

== prompt and confirm ==

(((dialog box)))(((input)))(((browser)))(((confirm function)))Browser
environments contain other functions besides `alert` for popping up
windows. You can ask the user an OK/Cancel question using
`confirm`. This returns a Boolean: `true` if the user clicks OK and
`false` if the user clicks Cancel.

[source,javascript]
----
confirm("Shall we, then?");
----

image::img/confirm.png[alt="A confirm dialog",width="8cm"]

(((input)))(((prompt function)))(((text input)))The `prompt` function
can be used to ask an “open” question. The first argument is the
question, the second one is the text that the user starts with. A line
of text can be typed into the dialog window, and the function will
return this text as a string.

[source,javascript]
----
prompt("Tell me everything you know.", "...");
----

image::img/prompt.png[alt="An prompt dialog",width="8cm"]

These two functions aren't used much in modern web programming, mostly
because you have no control over the way the resulting windows look,
but they are useful for toy programs and experiments.

== Control flow ==

(((execution order)))(((program)))(((control flow)))When your program
contains more than one ((statement)), the statements are executed,
predictably, from top to bottom. As a basic example, this program has
two statements. The first one asks the user for a number, and the
second, which is executed afterward, shows the ((square)) of that
number.

[source,javascript]
----
var theNumber = Number(prompt("Pick a number", ""));
alert("Your number is the square root of " +
      theNumber * theNumber);
----

(((number,conversion to)))(((type coercion)))(((Number
function)))(((String function)))(((Boolean
function)))(((Boolean,conversion to)))The function `Number` converts a
value to a number. We need that conversion because the result of
`prompt` is a string value, and we want a number. There are similar
functions called `String` and `Boolean` that convert values to those
types.

Here is the rather trivial schematic representation of straight
control flow:

image::img/controlflow-straight.svg[alt="Trivial control flow",width="4cm"]

== Conditional execution ==

(((Boolean)))(((control flow)))Executing statements in straight-line
order isn't the only option we have. An alternative is _((conditional
execution))_, where we choose between two different routes based on a
Boolean value, like this:

image::img/controlflow-if.svg[alt="Conditional control flow",width="4cm"]

(((syntax)))(((Number function)))(((if keyword)))Conditional execution
is written with the `if` keyword in JavaScript. In the simple case, we
just want some code to be executed if, and only if, a certain
condition holds. For example, in the previous program, we might want
to show the square of the input only if the input is actually a
number.

[source,javascript]
----
var theNumber = Number(prompt("Pick a number", ""));
if (!isNaN(theNumber))
  alert("Your number is the square root of " +
        theNumber * theNumber);
----

With this modification, if you enter “cheese”, no output will be shown.

The keyword `if` executes or skips a statement depending on the value
of a Boolean expression. The deciding expression is written after the
keyword, between ((parentheses)), followed by the statement to execute.

(((isNaN function)))The `isNaN` function is a standard JavaScript
function that returns `true` only if the argument it is given is
`NaN`. The `Number` function happens to return `NaN` when you give it
a string that doesn't represent a valid number. Thus, the condition
translates to “unless `theNumber` is not-a-number, do this”.

(((else keyword)))You often won't just have code that executes when a
condition holds true, but also code that handles the other case. This
alternate path is represented by the second arrow in the
diagram. The `else` keyword can be used, together with `if`, to create
two separate, alternative execution paths.

[source,javascript]
----
var theNumber = Number(prompt("Pick a number", ""));
if (!isNaN(theNumber))
  alert("Your number is the square root of " +
        theNumber * theNumber);
else
  alert("Hey. Why didn't you give me a number?");
----

(((if keyword,chaining)))If we have more than two paths to choose
from, multiple `if`/`else` pairs can be “chained” together. Here's an
example:

[source,javascript]
----
var num = Number(prompt("Pick a number", "0"));

if (num < 10)
  alert("Small");
else if (num < 100)
  alert("Medium");
else
  alert("Large");
----

The program will first check whether `num` is less than 10. If it is,
it chooses that branch, shows `"Small"`, and is done. If it isn't, it
takes the `else` branch, which itself contains a second `if`. If the
second condition (`< 100`) holds, that means the number is between 10
and 100, and `"Medium"` is shown. If it doesn't, the second, and last,
`else` branch is chosen.

The flow chart for this program looks something like this:

image::img/controlflow-nested-if.svg[alt="Nested if control flow",width="4cm"]



== Indenting Code ==

(((block)))(((code structure)))(((whitespace)))(((programming
style)))You've probably noticed the spaces I put in front of some
statements. In JavaScript, these are not required—the computer will
accept the program just fine without them. In fact, even the ((line))
breaks in programs are optional. You could write a program as a single
long line if you felt like it. The role of the ((indentation)) inside
blocks is to make the structure of the code stand out. In complex
code, where new blocks are opened inside other blocks, it can become
hard to see where one block ends and another begins. With proper
indentation, the visual shape of a program corresponds to the shape of
the blocks inside it. I like to use two spaces for every open block,
but tastes differ—some people use four spaces, and some people use
((tab character))s.


== Dispatching on a value with switch ==

(((syntax)))(((conditional execution)))(((dispatching)))(((if
keyword,chaining)))It is common for code to look like this:

// test: no

[source,javascript]
----
if (variable == "value1") action1();
else if (variable == "value2") action2();
else if (variable == "value3") action3();
else defaultAction();
----

(((colon character)))(((switch keyword)))There is a construct called
`switch` that is intended to solve such a “dispatch” in a more direct
way. Unfortunately, the syntax JavaScript uses for this (which it
inherited from the C/Java line of programming languages) is somewhat
awkward—a chain of `if` statements often looks better. Here is an
example:

[source,javascript]
----
switch (prompt("What is the weather like?")) {
  case "rainy":
    console.log("Remember to bring an umbrella.");
    break;
  case "sunny":
    console.log("Dress lightly.");
  case "cloudy":
    console.log("Go outside.");
    break;
  default:
    console.log("Unknown weather type!");
    break;
}
----

(((fallthrough)))(((comparison)))(((break keyword)))(((case
keyword)))(((default keyword)))You may put any number of `case` labels
inside the block opened by `switch`. The program will jump to the
label that corresponds to the value that `switch` was given or to
`default` if no matching value is found. It starts executing
statements there, even if they're under another label, until it
reaches a `break` statement. In some cases, such as the `"sunny"` case
in the example, this can be used to share some code between cases (it
recommends going outside for both sunny and cloudy weather). But
beware: it is easy to forget such a `break`, which will cause the
program to execute code you do not want executed.

== Capitalization ==

(((capitalization)))(((variable,naming)))(((whitespace)))Variable
names may not contain spaces, yet it is often helpful to use multiple
words to clearly describe what the variable represents. These are
pretty much your choices for writing a variable name with several
words in it:

----
fuzzylittleturtle
fuzzy_little_turtle
FuzzyLittleTurtle
fuzzyLittleTurtle
----

(((camel case)))(((programming style)))(((underscore character)))The
first style can be hard to read. Personally, I like the look of the
underscores, though that style is a little painful to type. The
((standard)) JavaScript functions, and most JavaScript programmers,
follow the bottom style—they capitalize every word except the first.
It is not hard to get used to little things like that, and code with
mixed naming styles can be jarring to read, so we will just follow
this ((convention)).

(((Number function)))(((constructor)))In a few cases, such as the
`Number` function, the first letter of a variable is also capitalized.
This was done to mark this function as a constructor. What a
constructor is will become clear in
link:06_object.html#constructors[Chapter 6]. For now, the important
thing is not to be bothered by this apparent lack of ((consistency)).

== Comments ==

(((readability)))Often, raw code does not convey all the information
you want a program to convey to human readers, or it conveys it in
such a cryptic way that people might not understand it. At other
times, you might just feel poetic or want to include some thoughts as
part of your program. This is what _((comment))s_ are for.

(((slash character)))(((line comment)))A comment is a piece of text
that is part of a program but is completely ignored by the computer.
JavaScript has two ways of writing comments. To write a single-line
comment, you can use two slash characters (`//`) and then the comment
text after it.

// test: no

[source,javascript]
----
var accountBalance = calculateBalance(account);
// It's a green hollow where a river sings
accountBalance.adjust();
// Madly catching white tatters in the grass.
var report = new Report();
// Where the sun on the proud mountain rings:
addToReport(accountBalance, report);
// It's a little valley, foaming like light in a glass.
----

(((block comment)))A `//` comment goes only to the end of the line. A
section of text between `/*` and `*/` will be ignored, regardless of
whether it contains line breaks. This is often useful for adding
blocks of information about a file or a chunk of program.

[source,javascript]
----
/*
 I first found this number scrawled on the back of one of
 my notebooks a few years ago. Since then, it has often
 dropped by, showing up in phone numbers and the serial
 numbers of products that I've bought. It obviously likes
 me, so I've decided to keep it.
*/
var myNumber = 11213;
----

== Summary ==

You now know that a program is built out of statements, which
themselves sometimes contain more statements. Statements tend to
contain expressions, which themselves can be built out of smaller
expressions.

Putting statements after one another gives you a program that is
executed from top to bottom. You can introduce disturbances in the
flow of control by using conditional (`if`, `else`, and `switch`) statements.

Variables can be used to file pieces of data under a name, and they
are useful for tracking state in your program. The environment is the
set of variables that are defined. JavaScript systems
always put a number of useful standard variables into your
environment.

Functions are special values that encapsulate a piece of program. You
can invoke them by writing `functionName(argument1, argument2)`. Such
a function call is an expression, and may produce a value.
